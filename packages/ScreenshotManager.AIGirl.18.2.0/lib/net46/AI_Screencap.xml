<?xml version="1.0"?>
<doc>
    <assembly>
        <name>AI_Screencap</name>
    </assembly>
    <members>
        <member name="T:Screencap.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Screencap.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Screencap.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Screencap.Properties.Resources.composite">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="T:Screencap.ScreenshotManager">
            <summary>
            Plugin for taking high quality screenshots with optional transparency.
            Brought to AI-Shoujo by essu - the local smug, benevolent modder.
            </summary>
        </member>
        <member name="F:Screencap.ScreenshotManager.GUID">
            <summary>
            GUID of the plugin, use with BepInDependency
            </summary>
        </member>
        <member name="F:Screencap.ScreenshotManager.Version">
            <summary>
            Version of the plugin, use with BepInDependency
            </summary>
        </member>
        <member name="E:Screencap.ScreenshotManager.OnPreCapture">
            <summary>
            Triggered before a screenshot is captured. For use by plugins adding screen effects incompatible with Screencap.
            </summary>
        </member>
        <member name="E:Screencap.ScreenshotManager.OnPostCapture">
            <summary>
            Triggered after a screenshot is captured. For use by plugins adding screen effects incompatible with Screencap.
            </summary>
        </member>
        <member name="T:Screencap.ScreenshotManager.Hooks">
            <summary>
            Disable built-in screenshots
            </summary>
        </member>
        <member name="M:Screencap.ScreenshotManager.Capture(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Capture the screen into a texture based on supplied arguments. Remember to RenderTexture.ReleaseTemporary the texture when done with it.
            </summary>
            <param name="width">Width of the resulting capture, after downscaling</param>
            <param name="height">Height of the resulting capture, after downscaling</param>
            <param name="downscaling">How much to oversize and then downscale. 1 for none.</param>
            <param name="transparent">Should the capture be transparent</param>
        </member>
        <member name="F:BepisPlugins.Metadata.PluginsVersion">
            <summary>
            Version number used be all plugins. Must be convertible to <see cref="T:System.Version"/>
            Use ReleaseVersion.HotfixVersion format
            </summary>
        </member>
        <member name="M:Extensions.Replace(System.String,System.String,System.String,System.StringComparison)">
            <summary>
            Returns a new string in which all occurrences of a specified string in the current instance are replaced with another 
            specified string according the type of search to use for the specified string.
            Stolen from https://stackoverflow.com/a/45756981
            </summary>
            <param name="str">The string performing the replace method.</param>
            <param name="oldValue">The string to be replaced.</param>
            <param name="newValue">The string replace all occurrences of <paramref name="oldValue"/>. 
            If value is equal to <c>null</c>, than all occurrences of <paramref name="oldValue"/> will be removed from the <paramref name="str"/>.</param>
            <param name="comparisonType">One of the enumeration values that specifies the rules for the search.</param>
            <returns>A string that is equivalent to the current string except that all instances of <paramref name="oldValue"/> are replaced with <paramref name="newValue"/>. 
            If <paramref name="oldValue"/> is not found in the current instance, the method returns the current instance unchanged.</returns>
        </member>
        <member name="M:Extensions.FindPosition(System.IO.Stream,System.Byte[])">
            <summary>
            Find first position of the byte sequence in the stream starting at current position.
            Returns position of first byte of the sequence.
            https://stackoverflow.com/questions/1550560/encoding-an-integer-in-7-bit-format-of-c-sharp-binaryreader-readstring
            </summary>
        </member>
        <member name="T:Shared.IMGUIUtils">
            <summary>
            Utility methods for working with IMGUI / OnGui.
            </summary>
        </member>
        <member name="M:Shared.IMGUIUtils.DrawSolidBox(UnityEngine.Rect)">
            <summary>
            Draw a gray non-transparent GUI.Box at the specified rect. Use before a GUI.Window or other controls to get rid of 
            the default transparency and make the GUI easier to read.
            <example>
            IMGUIUtils.DrawSolidBox(screenRect);
            GUILayout.Window(362, screenRect, TreeWindow, "Select character folder");
            </example>
            </summary>
        </member>
        <member name="M:Shared.IMGUIUtils.EatInputInRect(UnityEngine.Rect)">
            <summary>
            Block input from going through to the game/canvases if the mouse cursor is within the specified Rect.
            Use after a GUI.Window call or the window will not be able to get the inputs either.
            <example>
            GUILayout.Window(362, screenRect, TreeWindow, "Select character folder");
            Utils.EatInputInRect(screenRect);
            </example>
            </summary>
            <param name="eatRect"></param>
        </member>
        <member name="M:Shared.IMGUIUtils.DrawLabelWithOutline(UnityEngine.Rect,System.String,UnityEngine.GUIStyle,UnityEngine.Color,UnityEngine.Color,System.Int32)">
            <summary>
            Draw a label with an outline
            </summary>
            <param name="rect">Size of the control</param>
            <param name="text">Text of the label</param>
            <param name="style">Style to be applied to the label</param>
            <param name="txtColor">Color of the text</param>
            <param name="outlineColor">Color of the outline</param>
            <param name="outlineThickness">Thickness of the outline in pixels</param>
        </member>
        <member name="M:Shared.IMGUIUtils.DrawLabelWithShadow(UnityEngine.Rect,UnityEngine.GUIContent,UnityEngine.GUIStyle,UnityEngine.Color,UnityEngine.Color,UnityEngine.Vector2)">
            <summary>
            Draw a label with a shadow
            </summary>        
            <param name="rect">Size of the control</param>
            <param name="content">Contents of the label</param>
            <param name="style">Style to be applied to the label</param>
            <param name="txtColor">Color of the outline</param>
            <param name="shadowColor">Color of the text</param>
            <param name="shadowOffset">Offset of the shadow in pixels</param>
        </member>
        <member name="T:Pngcs.Chunks.ChunkCopyBehaviour">
            <summary>
            Behaviours for chunks transfer when reading and writing.
            </summary>
            <remarks>
            They are bitmasks, can be OR-ed
            </remarks>
        </member>
        <member name="F:Pngcs.Chunks.ChunkCopyBehaviour.COPY_NONE">
            <summary>
            Don't copy any chunk
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.ChunkCopyBehaviour.COPY_PALETTE">
            <summary>
            Copy the Palette, if present
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.ChunkCopyBehaviour.COPY_ALL_SAFE">
            <summary>
            Copy all SAFE chunks
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.ChunkCopyBehaviour.COPY_ALL">
            <summary>
            Copy all chunks (includes palette)
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.ChunkCopyBehaviour.COPY_PHYS">
            <summary>
            Copy Physical resolution (DPI)
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.ChunkCopyBehaviour.COPY_TEXTUAL">
            <summary>
            Copy all textual chunks (not safe)
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.ChunkCopyBehaviour.COPY_TRANSPARENCY">
            <summary>
            Copy transparency (not safe)
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.ChunkCopyBehaviour.COPY_UNKNOWN">
            <summary>
            Copy chunks unknown by our factory
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.ChunkCopyBehaviour.COPY_ALMOSTALL">
            <summary>
            Copy all known, except HIST, TIME and textual
            </summary>
        </member>
        <member name="T:Pngcs.Chunks.ChunkHelper">
            <summary>
            Static utility methods for CHunks
            </summary>
            <remarks>
            Client code should rarely need this, see PngMetada and ChunksList
            </remarks>
        </member>
        <member name="M:Pngcs.Chunks.ChunkHelper.ToBytes(System.String)">
            <summary>
            Converts to bytes using Latin1 (ISO-8859-1)
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunkHelper.ToString(System.Byte[])">
            <summary>
            Converts to String using Latin1 (ISO-8859-1)
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunkHelper.ToString(System.Byte[],System.Int32,System.Int32)">
            <summary>
             Converts to String using Latin1 (ISO-8859-1)
            </summary>
            <param name="x"></param>
            <param name="offset"></param>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunkHelper.ToBytesUTF8(System.String)">
            <summary>
            Converts to bytes using UTF-8
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunkHelper.ToStringUTF8(System.Byte[])">
            <summary>
            Converts to string using UTF-8
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunkHelper.ToStringUTF8(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts to string using UTF-8
            </summary>
            <param name="x"></param>
            <param name="offset"></param>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunkHelper.WriteBytesToStream(System.IO.Stream,System.Byte[])">
            <summary>
            Writes full array of bytes to stream
            </summary>
            <param name="stream"></param>
            <param name="bytes"></param>
        </member>
        <member name="M:Pngcs.Chunks.ChunkHelper.IsCritical(System.String)">
            <summary>
            Critical chunks: first letter is uppercase
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunkHelper.IsPublic(System.String)">
            <summary>
            Public chunks: second letter is uppercase
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunkHelper.IsSafeToCopy(System.String)">
            <summary>
            Safe to copy chunk: fourth letter is lower case
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunkHelper.PosNullByte(System.Byte[])">
            <summary>
            Finds position of null byte in array
            </summary>
            <param name="bytes"></param>
            <returns>-1 if not found</returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunkHelper.ShouldLoad(System.String,Pngcs.Chunks.ChunkLoadBehaviour)">
            <summary>
            Decides if a chunk should be loaded, according to a ChunkLoadBehaviour
            </summary>
            <param name="id"></param>
            <param name="behav"></param>
            <returns></returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunkHelper.FilterList(System.Collections.Generic.List{Pngcs.Chunks.PngChunk},Pngcs.Chunks.IChunkPredicate)">
            <summary>
            Filters a list of Chunks, keeping those which match the predicate
            </summary>
            <remarks>The original list is not altered</remarks>
            <param name="list"></param>
            <param name="predicateKeep"></param>
            <returns></returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunkHelper.TrimList(System.Collections.Generic.List{Pngcs.Chunks.PngChunk},Pngcs.Chunks.IChunkPredicate)">
            <summary>
            Filters a list of Chunks, removing those which match the predicate
            </summary>
            <remarks>The original list is not altered</remarks>
            <param name="list"></param>
            <param name="predicateRemove"></param>
            <returns></returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunkHelper.Equivalent(Pngcs.Chunks.PngChunk,Pngcs.Chunks.PngChunk)">
            <summary>
            Ad-hoc criteria for 'equivalent' chunks.
            </summary>
             <remarks>
            Two chunks are equivalent if they have the same Id AND either:
            1. they are Single
            2. both are textual and have the same key
            3. both are SPLT and have the same palette name
            Bear in mind that this is an ad-hoc, non-standard, nor required (nor wrong)
            criterion. Use it only if you find it useful. Notice that PNG allows to have
            repeated textual keys with same keys.
            </remarks>        
            <param name="c1">Chunk1</param>
            <param name="c2">Chunk1</param>
            <returns>true if equivalent</returns>
        </member>
        <member name="T:Pngcs.Chunks.ChunkLoadBehaviour">
            <summary>
            Defines what to do with non critical chunks when reading
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.ChunkLoadBehaviour.LOAD_CHUNK_NEVER">
            <summary>
            all non-critical chunks are skippped
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.ChunkLoadBehaviour.LOAD_CHUNK_KNOWN">
            <summary>
            load chunk if 'known' (registered with the factory)
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.ChunkLoadBehaviour.LOAD_CHUNK_IF_SAFE">
            <summary>
            load chunk if 'known' or safe to copy 
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.ChunkLoadBehaviour.LOAD_CHUNK_ALWAYS">
            <summary>
            load chunks always 
            
             Notice that other restrictions might apply, see PngReader.SkipChunkMaxSize PngReader.SkipChunkIds
            </summary>
        </member>
        <member name="T:Pngcs.Chunks.IChunkPredicate">
            <summary>
            Decides if another chunk "matches", according to some criterion
            </summary>
        </member>
        <member name="M:Pngcs.Chunks.IChunkPredicate.Matches(Pngcs.Chunks.PngChunk)">
            <summary>
            The other chunk matches with this one
            </summary>
            <param name="chunk">The other chunk</param>
            <returns>true if matches</returns>
        </member>
        <member name="T:Pngcs.Chunks.ChunkPredicateEquiv">
            <summary>
            An ad-hoc criterion, perhaps useful, for equivalence.
            <see cref="M:Pngcs.Chunks.ChunkHelper.Equivalent(Pngcs.Chunks.PngChunk,Pngcs.Chunks.PngChunk)"/> 
            </summary>
        </member>
        <member name="M:Pngcs.Chunks.ChunkPredicateEquiv.#ctor(Pngcs.Chunks.PngChunk)">
            <summary>
            Creates predicate based of reference chunk
            </summary>
            <param name="chunk"></param>
        </member>
        <member name="M:Pngcs.Chunks.ChunkPredicateEquiv.Matches(Pngcs.Chunks.PngChunk)">
            <summary>
            Check for match
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="T:Pngcs.Chunks.ChunkPredicateId">
            <summary>
            Match if have same Chunk Id
            </summary>
        </member>
        <member name="T:Pngcs.Chunks.ChunkPredicateId2">
            <summary>
            match if have same id and, if Text (or SPLT) if have the asame key
            </summary>
            <remarks>
            This is the same as ChunkPredicateEquivalent, the only difference is that does not requires
            a chunk at construction time
            </remarks>
        </member>
        <member name="T:Pngcs.Chunks.ChunkRaw">
             <summary> Wraps the raw chunk data </summary>
             <remarks>
             Short lived object, to be created while serialing/deserializing 
             
             Do not reuse it for different chunks
             
             See http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html
            </remarks>
        </member>
        <member name="F:Pngcs.Chunks.ChunkRaw.Len">
            <summary>
            The length counts only the data field, not itself, the chunk type code, or the CRC. Zero is a valid length.
            Although encoders and decoders should treat the length as unsigned, its value must not exceed 2^31-1 bytes.
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.ChunkRaw.IdBytes">
            <summary>
            Chunk Id, as array of 4 bytes
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.ChunkRaw.Data">
            <summary>
            Raw data, crc not included
            </summary>
        </member>
        <member name="M:Pngcs.Chunks.ChunkRaw.#ctor(System.Int32,System.String,System.Boolean)">
            <summary>
            Creates an empty raw chunk
            </summary>
        </member>
        <member name="M:Pngcs.Chunks.ChunkRaw.ComputeCrc">
            <summary>
            Called after setting data, before writing to os
            </summary>
        </member>
        <member name="M:Pngcs.Chunks.ChunkRaw.ToString">
            <summary>
            Just id and length
            </summary>
            <returns></returns>
        </member>
        <member name="T:Pngcs.Chunks.ChunksList">
             <summary>
             All chunks that form an image, read or to be written
             
             http://www.w3.org/TR/PNG/#table53
             </summary>
            
        </member>
        <member name="F:Pngcs.Chunks.ChunksList.chunks">
            <summary>
             Includes all chunks, but IDAT is a single pseudo chunk without data
            </summary>
        </member>
        <member name="M:Pngcs.Chunks.ChunksList.GetChunksKeys">
            <summary>
            Keys of processed (read or writen) chunks
            </summary>
            <returns>key:chunk id, val: number of occurrences</returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunksList.GetChunks">
            <summary>
            Returns a copy of the chunk list (but the chunks are not copied) 
            </summary>
            <remarks>This should not be used for general metadata handling
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunksList.AppendReadChunk(Pngcs.Chunks.PngChunk,System.Int32)">
            <summary>
            Adds chunk in next position. This is used only by the pngReader
            </summary>
            <param name="chunk"></param>
            <param name="chunkGroup"></param>
        </member>
        <member name="M:Pngcs.Chunks.ChunksList.GetById(System.String)">
            <summary>
            All chunks with this ID
            </summary>
            <remarks>The GetBy... methods never include queued chunks</remarks>
            <param name="id"></param>
            <returns>List, empty if none</returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunksList.GetById(System.String,System.String)">
            <summary>
            Same as ID, but we an additional discriminator for textual keys
            </summary>
            <remarks>If innerid!=null and the chunk is PngChunkTextVar or PngChunkSPLT, it's filtered by that id</remarks>
            <param name="id"></param>
            <param name="innerid">Only used for text and SPLT chunks</param>
            <returns>List, empty if none</returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunksList.GetById1(System.String)">
            <summary>
            Returns only one chunk 
            </summary>
            <param name="id"></param>
            <returns>First chunk found, null if not found</returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunksList.GetById1(System.String,System.Boolean)">
            <summary>
            Returns only one chunk
            </summary>
            <param name="id"></param>
            <param name="failIfMultiple">true, and more than one found: exception</param>
            <returns>null if not found</returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunksList.GetById1(System.String,System.String,System.Boolean)">
            <summary>
            Sames as <c>GetById1(String id, bool failIfMultiple)</c> but allows an additional innerid
            </summary>
            <param name="id"></param>
            <param name="innerid"></param>
            <param name="failIfMultiple">true, and more than one found: exception</param>
            <returns>null if not found</returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunksList.GetEquivalent(Pngcs.Chunks.PngChunk)">
            <summary>
            Finds all chunks "equivalent" to this one
            </summary>
            <param name="chunk"></param>
            <returns>Empty if nothing found</returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunksList.ToString">
            <summary>
            Only the amount of chunks
            </summary>
            <returns></returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunksList.ToStringFull">
            <summary>
            Detailed information, for debugging
            </summary>
            <returns></returns>
        </member>
        <member name="T:Pngcs.Chunks.ChunksListForWrite">
             <summary>
             Chunks written or queued to be written 
             http://www.w3.org/TR/PNG/#table53
             </summary>
            
        </member>
        <member name="M:Pngcs.Chunks.ChunksListForWrite.RemoveChunk(Pngcs.Chunks.PngChunk)">
             <summary>
            Remove Chunk: only from queued 
             </summary>
             <remarks>
             WARNING: this depends on chunk.Equals() implementation, which is straightforward for SingleChunks. For 
             MultipleChunks, it will normally check for reference equality!
             </remarks>
             <param name="c"></param>
             <returns></returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunksListForWrite.Queue(Pngcs.Chunks.PngChunk)">
            <summary>
            Adds chunk to queue
            </summary>
            <remarks>Does not check for duplicated or anything</remarks>
            <param name="chunk"></param>
            <returns></returns>
        </member>
        <member name="M:Pngcs.Chunks.ChunksListForWrite.ShouldWrite(Pngcs.Chunks.PngChunk,System.Int32)">
             this should be called only for ancillary chunks and PLTE (groups 1 - 3 - 5)
            
        </member>
        <member name="M:Pngcs.Chunks.ChunksListForWrite.GetQueuedChunks">
            <summary>
            chunks not yet writen - does not include IHDR, IDAT, END, perhaps yes PLTE
            </summary>
            <returns>THis is not a copy! Don't modify</returns>
        </member>
        <member name="T:Pngcs.Chunks.PngChunk">
            <summary>
            Represents a instance of a PNG chunk
            </summary>
            <remarks>
            Concrete classes should extend <c>PngChunkSingle</c> or <c>PngChunkMultiple</c>
            
            Note that some methods/fields are type-specific (GetOrderingConstraint(), AllowsMultiple())
            some are 'almost' type-specific (Id,Crit,Pub,Safe; the exception is <c>PngUKNOWN</c>), 
            and some are instance-specific
            
            Ref: http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html
            </remarks>
        </member>
        <member name="F:Pngcs.Chunks.PngChunk.Id">
            <summary>
            4 letters. The Id almost determines the concrete type (except for PngUKNOWN)
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.PngChunk.Crit">
            <summary>
            Standard basic properties, implicit in the Id
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.PngChunk.Pub">
            <summary>
            Standard basic properties, implicit in the Id
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.PngChunk.Safe">
            <summary>
            Standard basic properties, implicit in the Id
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.PngChunk.ImgInfo">
            <summary>
            Image basic info, mostly for some checks
            </summary>
        </member>
        <member name="P:Pngcs.Chunks.PngChunk.Priority">
            <summary>
            For writing. Queued chunks with high priority will be written as soon as possible
            </summary>
        </member>
        <member name="P:Pngcs.Chunks.PngChunk.ChunkGroup">
            <summary>
            Chunk group where it was read or writen
            </summary>
        </member>
        <member name="T:Pngcs.Chunks.PngChunk.ChunkOrderingConstraint">
            <summary>
            Restrictions for chunk ordering, for ancillary chunks
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.PngChunk.ChunkOrderingConstraint.NONE">
            <summary>
            No constraint, the chunk can go anywhere
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.PngChunk.ChunkOrderingConstraint.BEFORE_PLTE_AND_IDAT">
            <summary>
            Before PLTE (palette) - and hence, also before IDAT
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.PngChunk.ChunkOrderingConstraint.AFTER_PLTE_BEFORE_IDAT">
            <summary>
            After PLTE (palette), but before IDAT
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.PngChunk.ChunkOrderingConstraint.BEFORE_IDAT">
            <summary>
            Before IDAT (before or after PLTE)
            </summary>
        </member>
        <member name="F:Pngcs.Chunks.PngChunk.ChunkOrderingConstraint.NA">
            <summary>
            Does not apply
            </summary>
        </member>
        <member name="M:Pngcs.Chunks.PngChunk.#ctor(System.String,Pngcs.ImageInfo)">
            <summary>
            Constructs an empty chunk
            </summary>
            <param name="id"></param>
            <param name="imgInfo"></param>
        </member>
        <member name="M:Pngcs.Chunks.PngChunk.FactoryRegister(System.String,System.Type)">
            <summary>
            Registers a Chunk ID in the factory, to instantiate a given type
            </summary>
            <remarks>
            This can be called by client code to register additional chunk types
            </remarks>
            <param name="chunkId"></param>
            <param name="type">should extend PngChunkSingle or PngChunkMultiple</param>
        </member>
        <member name="M:Pngcs.Chunks.PngChunk.FactoryFromId(System.String,Pngcs.ImageInfo)">
            <summary>
            Creates one new blank chunk of the corresponding type, according to factoryMap (PngChunkUNKNOWN if not known)
            </summary>
            <param name="cid">Chunk Id</param>
            <param name="info"></param>
            <returns></returns>
        </member>
        <member name="M:Pngcs.Chunks.PngChunk.ToString">
            <summary>
            Basic info: Id, length, Type name
            </summary>
            <returns></returns>
        </member>
        <member name="M:Pngcs.Chunks.PngChunk.CreateRawChunk">
            <summary>
            Serialization. Creates a Raw chunk, ready for write, from this chunk content
            </summary>
        </member>
        <member name="M:Pngcs.Chunks.PngChunk.ParseFromRaw(Pngcs.Chunks.ChunkRaw)">
            <summary>
            Deserialization. Given a Raw chunk, just rad, fills this chunk content
            </summary>
        </member>
        <member name="M:Pngcs.Chunks.PngChunk.CloneDataFromRead(Pngcs.Chunks.PngChunk)">
            <summary>
            Override to make a copy (normally deep) from other chunk
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Pngcs.Chunks.PngChunk.AllowsMultiple">
            <summary>
            This is implemented in PngChunkMultiple/PngChunSingle
            </summary>
            <returns>Allows more than one chunk of this type in a image</returns>
        </member>
        <member name="M:Pngcs.Chunks.PngChunk.GetOrderingConstraint">
            <summary>
            Get ordering constrain
            </summary>
            <returns></returns>
        </member>
        <member name="T:Pngcs.Chunks.PngChunkIDAT">
            <summary>
            IDAT chunk http://www.w3.org/TR/PNG/#11IDAT
            
            This object is dummy placeholder - We treat this chunk in a very different way than ancillary chnks
            </summary>
        </member>
        <member name="T:Pngcs.Chunks.PngChunkIEND">
            <summary>
            IEND chunk  http://www.w3.org/TR/PNG/#11IEND
            </summary>
        </member>
        <member name="T:Pngcs.Chunks.PngChunkIHDR">
            <summary>
            IHDR chunk: http://www.w3.org/TR/PNG/#11IHDR
            </summary>
        </member>
        <member name="T:Pngcs.Chunks.PngChunkMultiple">
            <summary>
            A Chunk type that allows duplicate in an image
            </summary>
        </member>
        <member name="T:Pngcs.Chunks.PngChunkSingle">
            <summary>
            A Chunk type that does not allow duplicate in an image
            </summary>
        </member>
        <member name="T:Pngcs.Chunks.PngMetadata">
            <summary>Image Metadata, wrapper over a ChunksList</summary>
            <remarks>
            Additional image info, apart from the ImageInfo and the pixels themselves. 
            Includes Palette and ancillary chunks.
            This class provides a wrapper over the collection of chunks of a image (read or to write) and provides some high
            level methods to access them
            </remarks>
        </member>
        <member name="M:Pngcs.Chunks.PngMetadata.QueueChunk(Pngcs.Chunks.PngChunk,System.Boolean)">
            <summary>Queues the chunk at the writer</summary>
            <param name="chunk">Chunk, ready for write</param>
            <param name="lazyOverwrite">Ovewrite lazily equivalent chunks</param>
            <remarks>Warning: the overwriting applies to equivalent chunks, see <c>ChunkPredicateEquiv</c>
            and will only make sense for queued (not yet writen) chunks
            </remarks>
        </member>
        <member name="M:Pngcs.Chunks.PngMetadata.QueueChunk(Pngcs.Chunks.PngChunk)">
            <summary>Queues the chunk at the writer</summary>
            <param name="chunk">Chunk, ready for write</param>
        </member>
        <member name="T:Pngcs.FileHelper">
            <summary>
            A few utility static methods to read and write files
            </summary>
        </member>
        <member name="M:Pngcs.FileHelper.CreatePngWriter(System.String,Pngcs.ImageInfo,System.Boolean)">
            <summary>
            Given a filename and a ImageInfo, produces a PngWriter object, ready for writing.</summary>
            <param name="fileName">Path of file</param>
            <param name="imgInfo">ImageInfo object</param>
            <param name="allowOverwrite">Flag: if false and file exists, a PngjOutputException is thrown</param>
            <returns>A PngWriter object, ready for writing</returns>
        </member>
        <member name="T:Pngcs.FilterType">
            <summary>
            Internal PNG predictor filter, or a strategy to select it.
            </summary>
        </member>
        <member name="F:Pngcs.FilterType.FILTER_NONE">
            <summary>
            No filtering 
            </summary>
        </member>
        <member name="F:Pngcs.FilterType.FILTER_SUB">
            <summary>
            SUB filter: uses same row
            </summary>
        </member>
        <member name="F:Pngcs.FilterType.FILTER_UP">
            <summary>
             UP filter: uses previous row
            </summary>
        </member>
        <member name="F:Pngcs.FilterType.FILTER_AVERAGE">
             <summary>
            AVERAGE filter: uses neighbors
             </summary>
        </member>
        <member name="F:Pngcs.FilterType.FILTER_PAETH">
            <summary>
            PAETH predictor
            </summary>
        </member>
        <member name="F:Pngcs.FilterType.FILTER_DEFAULT">
            <summary>
            Default strategy: select one of the standard filters depending on global image parameters
            </summary>
        </member>
        <member name="F:Pngcs.FilterType.FILTER_AGGRESSIVE">
            <summary>
            Aggressive strategy: select dinamically the filters, trying every 8 rows
            </summary>
        </member>
        <member name="F:Pngcs.FilterType.FILTER_VERYAGGRESSIVE">
            <summary>
            Very aggressive and slow strategy: tries all filters for each row
            </summary>
        </member>
        <member name="F:Pngcs.FilterType.FILTER_CYCLIC">
            <summary>
            Uses all fiters, one for lines, in cyclic way. Only useful for testing.
            </summary>
        </member>
        <member name="F:Pngcs.FilterType.FILTER_UNKNOWN">
            <summary>
            Not specified, placeholder for unknown or NA filters. 
            </summary>
        </member>
        <member name="T:Pngcs.FilterWriteStrategy">
            <summary>
            Manages the writer strategy for selecting the internal png predictor filter
            </summary>
        </member>
        <member name="T:Pngcs.ImageInfo">
            <summary>
            Simple immutable wrapper for basic image info
            </summary>
            <remarks>
            Some parameters are clearly redundant
            The constructor requires an 'ortogonal' subset
            http://www.w3.org/TR/PNG/#11IHDR
            </remarks>
        </member>
        <member name="F:Pngcs.ImageInfo.Cols">
            <summary>
            Image width, in pixels
            </summary>
        </member>
        <member name="F:Pngcs.ImageInfo.Rows">
            <summary>
            Image height, in pixels
            </summary>
        </member>
        <member name="F:Pngcs.ImageInfo.BitDepth">
             <summary>
             Bits per sample (per channel) in the buffer. 
             </summary>
             <remarks>
             This is 8 or 16 for RGB/ARGB images. 
             For grayscale, it's 8 (or 1 2 4 ).
             For indexed images, number of bits per palette index (1 2 4 8).
            </remarks>
        </member>
        <member name="F:Pngcs.ImageInfo.Channels">
             <summary>
             Number of channels, used in the buffer 
             </summary>
             <remarks>
             WARNING: This is 3-4 for rgb/rgba, but 1 for palette/gray !
            </remarks>
        </member>
        <member name="F:Pngcs.ImageInfo.BitspPixel">
            <summary>
            Bits used for each pixel in the buffer 
            </summary>
            <remarks>equals <c>channels * bitDepth</c>
            </remarks>
        </member>
        <member name="F:Pngcs.ImageInfo.BytesPixel">
            <summary>
            Bytes per pixel, rounded up
            </summary>
            <remarks>This is mainly for internal use (filter)</remarks>
        </member>
        <member name="F:Pngcs.ImageInfo.BytesPerRow">
            <summary>
            Bytes per row, rounded up
            </summary>
            <remarks>equals <c>ceil(bitspp*cols/8)</c></remarks>
        </member>
        <member name="F:Pngcs.ImageInfo.SamplesPerRow">
            <summary>
            Samples (scalar values) per row
            </summary>
            <remarks>
            Equals <c>cols * channels</c>
            </remarks>
        </member>
        <member name="F:Pngcs.ImageInfo.SamplesPerRowPacked">
            <summary>
            Number of values in our scanline, which might be packed.
            </summary>
            <remarks>
            Equals samplesPerRow if not packed. Elsewhere, it's lower
            For internal use, mostly.
            </remarks>
        </member>
        <member name="F:Pngcs.ImageInfo.Alpha">
            <summary>
            flag: has alpha channel
            </summary>
        </member>
        <member name="F:Pngcs.ImageInfo.Greyscale">
            <summary>
            flag: is grayscale (G/GA)
            </summary>
        </member>
        <member name="F:Pngcs.ImageInfo.Indexed">
            <summary>
            flag: has palette
            </summary>
        </member>
        <member name="F:Pngcs.ImageInfo.Packed">
            <summary>
            flag: less than one byte per sample (bit depth 1-2-4) 
            </summary>
        </member>
        <member name="M:Pngcs.ImageInfo.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Simple constructor: only for RGB/RGBA
            </summary>
        </member>
        <member name="M:Pngcs.ImageInfo.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            General Constructor
            </summary>
            <param name="cols">Width in pixels</param>
            <param name="rows">Height in pixels</param>
            <param name="bitdepth">Bits per sample per channel</param>
            <param name="alpha">Has alpha channel</param>
            <param name="grayscale">Is grayscale</param>
            <param name="palette">Has palette</param>
        </member>
        <member name="M:Pngcs.ImageInfo.ToString">
            <summary>
            General information, for debugging
            </summary>
            <returns>Summary</returns>
        </member>
        <member name="T:Pngcs.ImageLine">
             <summary>
             Lightweight wrapper for an image scanline, for read and write
             </summary>
             <remarks>It can be (usually it is) reused while iterating over the image lines
             See <c>scanline</c> field doc, to understand the format.
            </remarks>
        </member>
        <member name="P:Pngcs.ImageLine.ImgInfo">
            <summary>
            ImageInfo (readonly inmutable)
            </summary>
        </member>
        <member name="P:Pngcs.ImageLine.Scanline">
            <summary>
            Samples of an image line
            </summary>
            <remarks>
            
            The 'scanline' is an array of integers, corresponds to an image line (row)
            Except for 'packed' formats (gray/indexed with 1-2-4 bitdepth) each int is a
            "sample" (one for channel), (0-255 or 0-65535) in the respective PNG sequence
            sequence : (R G B R G B...) or (R G B A R G B A...) or (g g g ...) or ( i i i
            ) (palette index)
            
            For bitdepth 1/2/4 ,and if samplesUnpacked=false, each value is a PACKED byte! To get an unpacked copy,
            see <c>Pack()</c> and its inverse <c>Unpack()</c>
            
            To convert a indexed line to RGB balues, see ImageLineHelper.PalIdx2RGB()
            (cant do the reverse)
            </remarks>
        </member>
        <member name="P:Pngcs.ImageLine.ScanlineB">
            <summary>
            Same as Scanline, but with one byte per sample. Only one of Scanline and ScanlineB is valid - this depends
            on SampleType}
            </summary>
        </member>
        <member name="P:Pngcs.ImageLine.Rown">
            <summary>
            tracks the current row number (from 0 to rows-1)
            </summary>
        </member>
        <member name="P:Pngcs.ImageLine.ElementsPerRow">
            <summary>
            Hown many elements has the scanline array
            =imgInfo.samplePerRowPacked, if packed, imgInfo.samplePerRow elsewhere
            </summary>
        </member>
        <member name="P:Pngcs.ImageLine.MaxSampleVal">
            <summary>
            Maximum sample value that this line admits: typically 255; less if bitdepth less than 8, 65535 if 16bits
            </summary>
        </member>
        <member name="P:Pngcs.ImageLine.SampleType">
            <summary>
            Determines if samples are stored in integers or in bytes
            </summary>
        </member>
        <member name="P:Pngcs.ImageLine.SamplesUnpacked">
            <summary>
            True: each scanline element is a sample.
            False: each scanline element has severals samples packed in a byte
            </summary>
        </member>
        <member name="P:Pngcs.ImageLine.FilterUsed">
            <summary>
            informational only ; filled by the reader
            </summary>
        </member>
        <member name="M:Pngcs.ImageLine.#ctor(Pngcs.ImageInfo,Pngcs.ImageLine.ESampleType,System.Boolean)">
            <summary>
            Constructs an ImageLine
            </summary>
            <param name="imgInfo">Inmutable copy of PNG ImageInfo</param>
            <param name="stype">Storage for samples:INT (default) or BYTE</param>
            <param name="unpackedMode">If true and bitdepth less than 8, samples are unpacked. This has no effect if biddepth 8 or 16</param>
        </member>
        <member name="M:Pngcs.ImageLine.PackInplaceByte(Pngcs.ImageInfo,System.Byte[],System.Byte[],System.Boolean)">
            size original: samplesPerRow sizeFinal: samplesPerRowPacked (trailing elements are trash!) *
        </member>
        <member name="M:Pngcs.ImageLine.SetScanLine(System.Int32[])">
            <summary>
            Makes a deep copy
            </summary>
            <remarks>You should rarely use this</remarks>
            <param name="b"></param>
        </member>
        <member name="M:Pngcs.ImageLine.GetScanLineCopy(System.Int32[])">
            <summary>
            Makes a deep copy
            </summary>
            <remarks>You should rarely use this</remarks>
            <param name="b"></param>
        </member>
        <member name="T:Pngcs.ImageLineHelper">
             <summary>
             Bunch of utility static methods to process/analyze an image line. 
             
             Not essential at all, some methods are probably to be removed if future releases.
             
             TODO: document this better
             
             </summary>
            
        </member>
        <member name="M:Pngcs.ImageLineHelper.ClampDouble(System.Double)">
            [0,1)
        </member>
        <member name="T:Pngcs.ImageLines">
            <summary>
            Wraps a set of rows from a image, read in a single operation, stored in a int[][] or byte[][] matrix
            
            They can be a subset of the total rows, but in this case they are equispaced.
            
            See also ImageLine
            </summary>
        </member>
        <member name="M:Pngcs.ImageLines.ImageRowToMatrixRow(System.Int32)">
            <summary>
            Translates from image row number to matrix row.
            If you are not sure if this image row in included, use better ImageRowToMatrixRowStrict
            
            </summary>
            <param name="imrow">Row number in the original image (from 0) </param>
            <returns>Row number in the wrapped matrix. Undefined result if invalid</returns>
        </member>
        <member name="M:Pngcs.ImageLines.ImageRowToMatrixRowStrict(System.Int32)">
            <summary>
            translates from image row number to matrix row
            </summary>
            <param name="imrow">Row number in the original image (from 0) </param>
            <returns>Row number in the wrapped matrix. Returns -1 if invalid</returns>
        </member>
        <member name="M:Pngcs.ImageLines.MatrixRowToImageRow(System.Int32)">
            <summary>
            Translates from matrix row number to real image row number
            </summary>
            <param name="mrow"></param>
            <returns></returns>
        </member>
        <member name="M:Pngcs.ImageLines.GetImageLineAtMatrixRow(System.Int32)">
            <summary>
            Constructs and returns an ImageLine object backed by a matrix row.
            This is quite efficient, no deep copy.
            </summary>
            <param name="mrow">Row number inside the matrix</param>
            <returns></returns>
        </member>
        <member name="T:Pngcs.PngCsUtils">
            <summary>
            Utility functions for C# porting
            </summary>
        </member>
        <member name="T:Pngcs.PngHelperInternal">
            <summary>
            Some utility static methods for internal use.
            </summary>
        </member>
        <member name="M:Pngcs.PngHelperInternal.GetCRC">
             <summary>
             thread-singleton crc engine 
             </summary>
            
        </member>
        <member name="T:Pngcs.PngIDatChunkOutputStream">
             <summary>
             outputs the stream for IDAT chunk , fragmented at fixed size (32k default).
             </summary>
            
        </member>
        <member name="T:Pngcs.PngjException">
            <summary>
            Gral exception class for PNGCS library
            </summary>
        </member>
        <member name="T:Pngcs.PngjExceptionInternal">
            <summary> Exception for internal problems </summary>
        </member>
        <member name="T:Pngcs.PngjOutputException">
            <summary>
            Exception associated with input (reading) operations
            </summary>
        </member>
        <member name="T:Pngcs.PngjUnsupportedException">
            <summary>
            Exception for unsupported operation or feature
            </summary>
        </member>
        <member name="T:Pngcs.PngWriter">
            <summary>
             Writes a PNG image, line by line.
            </summary>
        </member>
        <member name="F:Pngcs.PngWriter.ImgInfo">
            <summary>
            Basic image info, inmutable
            </summary>
        </member>
        <member name="F:Pngcs.PngWriter.filename">
            <summary>
            filename, or description - merely informative, can be empty
            </summary>
        </member>
        <member name="P:Pngcs.PngWriter.CompressionStrategy">
            Deflate algortithm compression strategy
        </member>
        <member name="P:Pngcs.PngWriter.CompLevel">
            <summary>
            zip compression level (0 - 9)
            </summary>
            <remarks>
            default:6
            
            9 is the maximum compression
            </remarks>
        </member>
        <member name="P:Pngcs.PngWriter.ShouldCloseStream">
            <summary>
            true: closes stream after ending write
            </summary>
        </member>
        <member name="P:Pngcs.PngWriter.IdatMaxSize">
            <summary>
            Maximum size of IDAT chunks
            </summary>
            <remarks>
            0=use default (PngIDatChunkOutputStream 32768)
            </remarks>
        </member>
        <member name="F:Pngcs.PngWriter.metadata">
            <summary>
            A high level wrapper of a ChunksList : list of written/queued chunks
            </summary>
        </member>
        <member name="F:Pngcs.PngWriter.chunksList">
            <summary>
            written/queued chunks
            </summary>
        </member>
        <member name="F:Pngcs.PngWriter.rowb">
            <summary>
            raw current row, as array of bytes,counting from 1 (index 0 is reserved for filter type)
            </summary>
        </member>
        <member name="F:Pngcs.PngWriter.rowbprev">
            <summary>
            previuos raw row
            </summary>
        </member>
        <member name="F:Pngcs.PngWriter.rowbfilter">
            <summary>
            raw current row, after filtered
            </summary>
        </member>
        <member name="P:Pngcs.PngWriter.CurrentChunkGroup">
            <summary>
            number of chunk group (0-6) last writen, or currently writing
            </summary>
            <remarks>see ChunksList.CHUNK_GROUP_NNN</remarks>
        </member>
        <member name="M:Pngcs.PngWriter.#ctor(System.IO.Stream,Pngcs.ImageInfo)">
            <summary>
            Constructs a PngWriter from a outputStream, with no filename information
            </summary>
            <param name="outputStream"></param>
            <param name="imgInfo"></param>
        </member>
        <member name="M:Pngcs.PngWriter.#ctor(System.IO.Stream,Pngcs.ImageInfo,System.String)">
            <summary>
            Constructs a PngWriter from a outputStream, with optional filename or description
            </summary>
            <remarks>
            After construction nothing is writen yet. You still can set some
            parameters (compression, filters) and queue chunks before start writing the pixels.
            
            See also <c>FileHelper.createPngWriter()</c>
            </remarks>
            <param name="outputStream">Opened stream for binary writing</param>
            <param name="imgInfo">Basic image parameters</param>
            <param name="filename">Optional, can be the filename or a description.</param>
        </member>
        <member name="M:Pngcs.PngWriter.Init">
            <summary>
            init: is called automatically before writing the first row
            </summary>
        </member>
        <member name="M:Pngcs.PngWriter.WriteSignatureAndIHDR">
            <summary>
            Write id signature and also "IHDR" chunk
            </summary>
        </member>
        <member name="M:Pngcs.PngWriter.SumRowbfilter">
            <summary> Sums absolute value </summary>
        </member>
        <member name="M:Pngcs.PngWriter.ComputeCompressionRatio">
            <summary>
            Computes compressed size/raw size, approximate
            </summary>
            <remarks>Actually: compressed size = total size of IDAT data , raw size = uncompressed pixel bytes = rows * (bytesPerRow + 1)
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Pngcs.PngWriter.End">
            <summary>
            Finalizes the image creation and closes the file stream.
            This MUST be called after writing the lines.
            </summary>  
        </member>
        <member name="M:Pngcs.PngWriter.GetFilename">
            <summary>
             Filename or description, from the optional constructor argument.
            </summary>
        </member>
        <member name="M:Pngcs.PngWriter.WriteRow(Pngcs.ImageLine,System.Int32)">
            <summary>
            this uses the row number from the imageline!
            </summary>
        </member>
        <member name="M:Pngcs.PngWriter.WriteRowInt(System.Int32[],System.Int32)">
            <summary>
            Writes a full image row.
            </summary>
            <remarks>
            This must be called sequentially from n=0 to
            n=rows-1 One integer per sample , in the natural order: R G B R G B ... (or
            R G B A R G B A... if has alpha) The values should be between 0 and 255 for
            8 bitspc images, and between 0- 65535 form 16 bitspc images (this applies
            also to the alpha channel if present) The array can be reused.
            </remarks>
            <param name="newrow">Array of pixel values</param>
            <param name="rown">Number of row, from 0 (top) to rows-1 (bottom)</param>
        </member>
        <member name="M:Pngcs.PngWriter.WriteRowsInt(System.Int32[][])">
            <summary>
            Writes all the pixels, calling writeRowInt() for each image row
            </summary>
        </member>
        <member name="M:Pngcs.PngWriter.WriteRowsByte(System.Byte[][])">
            <summary>
            Writes all the pixels, calling writeRowByte() for each image row
            </summary>
        </member>
        <member name="M:Pngcs.PngWriter.SetFilterType(Pngcs.FilterType)">
            <summary>
            Sets internal prediction filter type, or strategy to choose it.
            </summary>
            <remarks>
            This must be called just after constructor, before starting writing.
            
            Recommended values: DEFAULT (default) or AGGRESIVE
            </remarks>
            <param name="filterType">One of the five prediction types or strategy to choose it</param>
        </member>
        <member name="T:Pngcs.ProgressiveOutputStream">
             <summary>
             stream that outputs to memory and allows to flush fragments every 'size'
             bytes to some other destination
             </summary>
            
        </member>
        <member name="M:Pngcs.ProgressiveOutputStream.CheckFlushBuffer(System.Boolean)">
             <summary>
             if it's time to flush data (or if forced==true) calls abstract method
             flushBuffer() and cleans those bytes from own buffer
             </summary>
            
        </member>
        <member name="M:Pngcs.Unity.PNG.IndexPngToTexture(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary> Texture2D's rows start from the bottom while PNG from the top. Hence inverted y/row. </summary>
        </member>
        <member name="M:Pngcs.Zlib.AZlibInputStream.GetImplementationId">
            <summary>
            mainly for debugging
            </summary>
            <returns></returns>
        </member>
        <member name="M:Pngcs.Zlib.AZlibOutputStream.GetImplementationId">
            <summary>
            mainly for debugging
            </summary>
            <returns></returns>
        </member>
        <member name="T:Pngcs.Zlib.ZlibInputStreamMs">
            <summary>
            Zip input (deflater) based on Ms DeflateStream (.net 4.5)
            </summary>
        </member>
    </members>
</doc>
